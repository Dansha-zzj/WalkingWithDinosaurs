////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// define uniforms
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uniform float uOpacityClouds;
uniform float uFrameWeight;
uniform float uCloudsMinValue;
uniform float uCloudsMaxValue;
uniform sampler2D thisCloudsFrame;
uniform sampler2D nextCloudsFrame;
uniform sampler2D cloudsTexture;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// varying from vertex shader
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
varying vec2 vUv;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// define functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// remap color range
float remap(float value, float inMin, float inMax, float outMin, float outMax) {

    return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// main program
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void main()	{

// interpolate model data between two time steps
vec4 cloudsValueInt;

// standard bilinear interpolation
cloudsValueInt = mix(texture2D(thisCloudsFrame,vUv),texture2D(nextCloudsFrame,vUv),uFrameWeight);

float cloudsValueRemapped = remap( cloudsValueInt.r, uCloudsMinValue, uCloudsMaxValue, 0.0, 1.0 );

vec4 colorClouds = texture2D( cloudsTexture, vUv * 2.0 );
//vec4 colorClouds = vec4(0.9);

gl_FragColor = vec4(colorClouds.rgb, cloudsValueRemapped);
gl_FragColor.a *= uOpacityClouds;


}